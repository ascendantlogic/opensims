/**
 * @LICENSE@
 */

package org.opensims.db.om;

/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Fri Aug 06 09:03:47 CDT 2004]
 *
 * <P>
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 * </P>
 *
 * $CVSId: Host.java,v 1.27 2007/02/20 00:42:36 jeff Exp $
 * $Id: Host.java 1 2008-01-10 18:37:05Z smoot $
 * @version $Revision: 1.27 $
 * @author Paco NATHAN <paco@symbiot.com>
 * @author Mike W. ERWIN <mikee@symbiot.com>
 * @see <A href="/docs/torque/opensims-schema.html#host">Torque-generated SQL Database Schema</A>
 */

public class
    Host
    extends org.opensims.db.om.BaseHost
    implements org.apache.torque.om.Persistent,
	       org.opensims.model.HostOrBogey
{
    // protected fields

    protected org.opensims.Manager manager = null;
    protected org.opensims.IPv4 ipv4 = null;
    protected org.jdom.Element node = null;
    protected org.opensims.geoloc.CountryInfo country_info = null;
    protected boolean warning_flag = false;
    protected Object host_info = new Object();

    /** The last time this host was saved */
    private long last_save_tick = 0;
                                          
    // quality assurance

    private static org.apache.log4j.Logger log_ = org.apache.log4j.Logger.getLogger(org.opensims.db.om.Host.class.getName());


    /**
     * Render for output as a String
     */

    public String
	getSummary ()
	{
		StringBuffer buf = new StringBuffer();
	
		try {
			buf.append("(");
			buf.append(getId());
			buf.append(")\t ip_addr ");
			buf.append(getIpAddr());
			buf.append("\n\t created: ");
			buf.append(getCreated());
			buf.append("\n\t last_tick: ");
			buf.append(getManager().getCorrelator().getTick() - getTick());
	
			if (getNetwork() != null) {
				buf.append("n\t network: ");
				buf.append(getNetwork());
			}
	
			if (country_info != null) {
				buf.append("\n\t country: ");
				buf.append(country_info.toString());
			}
		}
		catch (Exception e) {
			log_.error("getSummary", e);
		}
	
		return buf.toString();
	}

    public void save() throws Exception
	{
		super.save();
		// this was throwing null pointer exception
		//last_save_tick = getManager().getCorrelator().getTick();
		this.last_save_tick = System.currentTimeMillis();
	}
	
    /**
     * Get the last_tick value - for expiry
     */

    public long
	getLastSaveTick ()
    {
		return last_save_tick;
    }

    //////////////////////////////////////////////////////////////////////
    // Tickable methods
    //////////////////////////////////////////////////////////////////////

    /**
     * Get the Manager
     */

    public org.opensims.Manager
    getManager ()
    {
		return manager;
    }


    /**
     * Set the Manager
     */

    public void
	setManager (org.opensims.Manager manager)
    {
		this.manager = manager;
    }


    /**
     * Get the last_tick value - for expiry
     */

    public long
	getLastTick ()
    {
		return getTick();
    }


    /**
     * Set the last_tick value - for expiry
     */

    public void
	setLastTick (long last_tick)
    {
		setTick(last_tick);
    }

    /**
     * Build a key for a hashtable lookup
     */

    public static String
	getKey (org.opensims.IPv4 ipv4)
    {
		return ipv4.toString();
    }


    /**
     * Build a key for a hashtable lookup
     */

    public String
	getKey ()
    {
		String key = null;
	
		try {
			key = getIpAddr();
		}
		catch (Exception e) {
			log_.error("get key", e);
		}
	
		return key;
    }


    /**
     * Check the expiry date/time
     */

    public boolean
        checkExpiry (long model_tick)
    {
        boolean result = false;
        long period = model_tick - getLastTick();

        if (period > org.opensims.Tickable.HOST_EXPIRY_PERIOD) {
			result = true;
        }

        return result;
    }


    //////////////////////////////////////////////////////////////////////
    // Comparable methods
    //////////////////////////////////////////////////////////////////////

    /**
     * Compares this object with the specified object for order
     */

    public int
	compareTo (Object o)
    {
		int result = 0;
	
		try {
			org.opensims.model.HostOrBogey other = (org.opensims.model.HostOrBogey) o;
	
			long this_addr = this.getIPv4().getNetworkAddr();
			long other_addr = other.getIPv4().getNetworkAddr();
	
			if (this_addr < other_addr) {
				result = -1;
			}
			else if (this_addr > other_addr) {
				result = 1;
			}
		}
		catch (Exception e) {
			log_.error("compare hosts", e);
		}
	
		return result;
    }


    //////////////////////////////////////////////////////////////////////
    // misc. access methods
    //////////////////////////////////////////////////////////////////////

    /**
     * Get the IP address
     */

    public org.opensims.IPv4
	getIPv4 ()
	throws Exception
    {
		if (ipv4 == null) {
			setIPv4(new org.opensims.IPv4(getIpAddr()));
		}
	
		return ipv4;
    }


    /**
     * Set the IP address of this host
     */

    public void
	setIPv4 (org.opensims.IPv4 ipv4)
    {
		this.ipv4 = ipv4;
    }


    /**
     * Get the database ID
     */

    public String
    getHostId ()
    {
		return Integer.toString(getId());
    }


    /**
     * Set the database ID
     */

    public void
    setHostId (String host_id)
    {
	/**
	 * @TODO fix this - not needed
	 */
    }


    /**
     * Get the geolocation info
     */

    public org.opensims.geoloc.CountryInfo
	getCountryInfo ()
    {
		return country_info;
    }


    /**
     * Set the geolocation info
     */

    public void
	setCountryInfo (org.opensims.geoloc.CountryInfo country_info)
    {
		// check whether we need to populate the geolocation info
		this.country_info = country_info;
	
		if ((country_info != null) &&
			country_info.getIsKnown() &&
			org.opensims.geoloc.CountryInfo.UNKNOWN_CODE.equals(getCountry())
			) {
			setCountry(country_info.getCode());
		}
    }


    /**
     * Get the XML node
     */

    public org.jdom.Element
	getNode ()
    {
		return node;
    }


    /**
     * Set the XML node
     */

    public void
	setNode (org.jdom.Element node)
    {
		this.node = node;
    }


    /**
     * Is this a host or a bogey?
     */

    public boolean
	isBogey ()
    {
		return (getNetwork() == null);
    }


    /**
     * Get the incident role
     */

    public String
	getRole ()
    {
		return isBogey() ? org.opensims.xml.Node.ATK_NODE : org.opensims.xml.Node.DEF_NODE;
    }


    /**
     * Get the warning flag.
     */

    public boolean
	getWarningFlag ()
    {
		return warning_flag;
    }


    /**
     * Set the warning flag.
     */

    public void
	setWarningFlag (boolean warning_flag)
    {
		this.warning_flag = warning_flag;
    }


    /**
     * Get the misc. host info.
     */

    public Object
	getHostInfo ()
    {
		return host_info;
    }


    /**
     * Set the misc. host info.
     */

    public void
	setHostInfo (Object host_info)
    {
		this.host_info = host_info;
    }


    //////////////////////////////////////////////////////////////////////
    // Reportable methods
    //////////////////////////////////////////////////////////////////////

    /**
     * Lookup the domain name.
     */

    public String
	getDomainName ()
    {
		String fqdn = null;
	
		try {
			fqdn = java.net.InetAddress.getByName(getIPv4().toString()).getCanonicalHostName();
		}
		catch (Exception e) {
			log_.error("dns lookup", e);
		}
	
		return fqdn;
    }
    
    
    /**
     * Sets a group to this Host, returns the group added or null
     */

    public String
	setGroup (String group)
    {
    	try {
			org.apache.torque.util.Criteria crit = new org.apache.torque.util.Criteria();
			org.opensims.db.om.Org organization = null;
			
			if (group == null) {
				group = "admin_group";
			}
			
			crit.add(org.opensims.db.om.OrgPeer.ORG_NAME, group);
			java.util.Iterator group_iter = org.opensims.db.om.OrgPeer.doSelect(crit).iterator();
			if (group_iter.hasNext()) {
				organization = (org.opensims.db.om.Org) group_iter.next();
			}
			if (organization != null) {			
				org.opensims.db.om.HostOrgLink host_org_link = new org.opensims.db.om.HostOrgLink();	
				this.addHostOrgLink(host_org_link);
				organization.addHostOrgLink(host_org_link);
				this.save();
				host_org_link.save();
				
				if (log_.isDebugEnabled()) {
					log_.debug("Torque - host<->org link added: " + this.toString() + " <-> " + organization.toString());
				}
			}
			else {
				group = null;
			}
		}
		catch (Exception e) {
			log_.error("using Torque to access host table", e);
		}
		
		return group;
    }
    
    
    /**
     * Sets a group to this Host
     */

    public String
	setGroup ()
    {
    	return setGroup("admin_group");
    }
    
    /**
     * Lookup the groups/orgs associated with this host.
     *  (comma delimeted list)
     */

    public String
	getGroups ()
    {
		String groups = null;	
		
		try {
			org.apache.torque.util.Criteria crit = new org.apache.torque.util.Criteria();
			crit.add(org.opensims.db.om.HostOrgLinkPeer.HOST_ID, getId());
			java.util.Iterator link_iter = org.opensims.db.om.HostOrgLinkPeer.doSelectJoinHost(crit).iterator();
			
			while (link_iter.hasNext()) {
				org.opensims.db.om.HostOrgLink hostOrgLink = (org.opensims.db.om.HostOrgLink) link_iter.next();
				if (groups != null)
					groups += "," + hostOrgLink.getOrganization();
				else
					groups = hostOrgLink.getOrganization();
			}	
			// We should ALWAYS find "admin_group", if not add it
			if (groups == null) {
				groups = this.setGroup();
			}
		}
		catch (Exception e) {
			log_.error("Torque error on host/group join", e);
		}
		return groups;
    }

    /**
     * Removes the Group Association from this Host
     */

    public void
	removeGroup (String group)
    {
    	int rc= 0;
    	
		try {
		
			// Disallow deletion of the admin_group
			if (!group.equals("admin_group")) {
			
				// RAW SQL required to do the delete, Torque insists on a primary key to do it with doDelete() --ME
				String sql = "DELETE FROM host_org_link WHERE host_id='" + getId() + "' AND organization='" + group + "'; ";
				rc = org.opensims.db.om.HostOrgLinkPeer.executeStatement(sql);
				
				/*
					org.apache.torque.util.Criteria crit = new org.apache.torque.util.Criteria();
					crit.add(org.opensims.db.om.HostOrgLinkPeer.HOST_ID, getId());
					crit.add(org.opensims.db.om.HostOrgLinkPeer.ORGANIZATION, group);
					org.opensims.db.om.HostOrgLinkPeer.doDelete(crit);
				*/
				this.save();
			}
		}
		catch (Exception e) {
			log_.error("Torque error on host/group join", e);
		}
    }


    /**
     * Lookup the provided groups and determine it it's associated with this host.
     */

    public boolean
	isInGroup (String group)
    {
    	boolean found = false;
    	
		try {
			org.apache.torque.util.Criteria crit = new org.apache.torque.util.Criteria();
			crit.add(org.opensims.db.om.HostOrgLinkPeer.HOST_ID, getId());
			java.util.Iterator link_iter = org.opensims.db.om.HostOrgLinkPeer.doSelectJoinHost(crit).iterator();
			
			while (link_iter.hasNext()) {
				org.opensims.db.om.HostOrgLink hostOrgLink = (org.opensims.db.om.HostOrgLink) link_iter.next();
				
				if (hostOrgLink.getOrganization().equals(group)) {
					found = true;
				}
			}	
		}
		catch (Exception e) {
			log_.error("Torque error on host/group join", e);
		}
		return found;
    }


    /**
     * Format an XML node for rendering a report
     */

    public org.jdom.Element
	getReportNode ()
    {
		org.jdom.Element report_node = getExportNode();
	
		// lookup the domain name	
		String fqdn = getDomainName();
	
		if (fqdn != null) {
			report_node.setAttribute("fqdn", fqdn);
		}
	
		// populate the geoloc info
		org.jdom.Element content_node = getNode();
	
		if (content_node != null) {
			report_node.addContent((org.jdom.Element) content_node.clone());
		}
	
		if (getCountryInfo() != null) {
			org.jdom.Element fixer_node = getCountryInfo().getFixerNode();
	
			if (fixer_node != null) {
				report_node.addContent((org.jdom.Element) fixer_node.clone());
			}
		}
	
		return report_node;
    }


    //////////////////////////////////////////////////////////////////////
    // Exportable methods
    //////////////////////////////////////////////////////////////////////

    /**
     * Format an XML node for export
     */

    public org.jdom.Element
	getExportNode ()
	{
		org.jdom.Element export_node = null;
	
		try {
			if (isBogey()) {
				export_node = new org.jdom.Element(org.opensims.xml.Node.ATK_NODE);
		
				export_node.setAttribute("id", getHostId());
				export_node.setAttribute("ip", getIpAddr());
		
				String country_code = "PIRATE";
				String country_name = "unknown";
		
				if ((country_info != null) && country_info.getIsKnown()) {
					country_code = country_info.getCode();
					country_name = country_info.getName();
				}
		
				export_node.setAttribute("date", getManager().getCorrelator().formatTick(getLastTick()));
				export_node.setAttribute("cc", country_code);
				export_node.setAttribute("country", country_name);
				export_node.setAttribute("warn", getWarningFlag() ? "1" : "0");
			}
			else {
				export_node = new org.jdom.Element(org.opensims.xml.Node.DEF_NODE);	
				String os_family = org.opensims.model.HostOrBogey.UNKNOWN_OS;
		
				if (getNode() != null) {
					org.jdom.Element platform_node = getNode().getChild(org.opensims.xml.Node.PLATFORM_NODE);
		
					if (platform_node != null) {
						os_family = platform_node.getAttributeValue("osfamily");
					}
				}
		
				export_node.setAttribute("date", getManager().getCorrelator().formatTick(getLastTick()));
				export_node.setAttribute("id", getHostId());
				export_node.setAttribute("ip", getIpAddr());
				export_node.setAttribute("os", os_family);
				export_node.setAttribute("warn", getWarningFlag() ? "1" : "0");
			}
		}
		catch (Exception e) {
			log_.error("get export node", e);
		}
	
		return export_node;
	}


    /**
     * Return a boolean indicating whether or not an alert is targetting a host's open port
     */
    public boolean
    hostHasOpenPort (org.opensims.db.om.Alert alert)
    {
    	boolean	hasOpenPort = false;
    	
    	if (!alert.getDstPort().equals("0"))
    	{
			org.jdom.Element	serviceNode = hostServiceNodeTargetedByAlert(alert);
			
			if (serviceNode != null)
			{
				hasOpenPort = true;
			}
    	}
    	
    	return hasOpenPort;
    }


    /**
     * Extract the service node that matches an alert's destination protocol and port
     */
    public org.jdom.Element
	hostServiceNodeTargetedByAlert (org.opensims.db.om.Alert alert)
	{
		org.jdom.Element serviceNode = null;
		
		if (!alert.getDstPort().equals("0"))
		{
			try
			{
				StringBuffer path = new StringBuffer();
				
			//	path.append("//").append(org.opensims.xml.Node.SERVICE_NODE);
				path.append(org.opensims.xml.Node.SERVICE_NODE);
				path.append("[");
				path.append("@protocol = '" + alert.getProtocol() + "'");
				path.append(" and ");
				path.append("@port = '" + alert.getDstPort() + "'");
				path.append(" and ");
				path.append("@state = 'open'");
				path.append("]");
				
				org.jdom.xpath.XPath xpath = org.jdom.xpath.XPath.newInstance(path.toString());
				serviceNode = (org.jdom.Element)xpath.selectSingleNode(getNode());
				
				if (log_.isDebugEnabled())
				{
					log_.debug("Raw path: " + path);
					log_.debug("service xpath |" + xpath.toString() + "| finds node: " + serviceNode);
					if (serviceNode != null)
					{
						log_.debug("service node: " + org.opensims.xml.XmlBuilder.formatXML(serviceNode, false, true));
					}
				}
			}
			catch (Exception e)
			{
				log_.error("Finding service node on a host target by an alert", e);
			}
		}
		
		return serviceNode;
	}
}
